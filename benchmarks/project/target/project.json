{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":340048479954227266,"abi":{"parameters":[{"name":"x","type":{"kind":"struct","path":"quantized::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]},"visibility":"private"},{"name":"y","type":{"kind":"struct","path":"quantized::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::cmp::Ordering","fields":[{"name":"result","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1XXW7bMAym/5p4QwZsSTEMBbrtBpJ/YvvNwLpL7M1p7HPkJnveAXajHWQxSjUsLdttQ6EoUAKBZMn69PETTSoe3Fl8/H3AfoitB0Pzsa2xVeeZplip2mZZWyStTnWjkmpX5irLd9tSlzov831SpmlbZmVR7apCVTpLW93lVdohmCfHS/nE54Dq4uGAaQ9sLMQxauErEe1crODxWLczWDqU00uFeDY+jNtj95rjTTG9J2LPmA4ENaEfd2TImiCOYPj1B8wZyWCZ4apn5lUkyOtCLhgU1bTHPTjWNBTEktR08QRN5/aimi5Q095vH+wVS/ojlExMlO/SJeGlA9xYMEBc+R0TgYVwFYEUvw75Apq23Z3FIBuoIfOZnhnt++RdOv77z/Xfq3/+L7DoZ5tbTMzFI3MmoX5n7/mEi2AV1THBlcYvVbal8euAfxrDw5uRC30MpgN8ZWLkx+GEz33pbYXPNF7NmiXOA2lvCJ7H5n5a9nLp5zEOMoMfOsA/WrK28Dd79fpcYT+wvOexNQGMnwNYxjwLDteVnlv9PJ8Hl0ju55Rv9GLM13G/6foIhn5HDJ+fKVj2CEbW2nD9CT/m1lLtVzA8R8PnPZxya3h4yL/GcXWGFeXpchQgfgTDOKL7R+z9b/j8jvCnftTP5NkVje7SpmvyZr/PbptPDB+IZr1OX7H/VosmLXVcKxLHOdRai2z5dKoW8W+utxucs9UpWosMnsuafoyD3PE56TWM149egy9wMqprBON1JGLvbrDt/5R/HMG7mMBbwfj59us+Yz+2YICgVjYenoXHysLDrHkNufwan186lxudTHsJ8nopkss3bvDvcxW1S9LfMD9pPqqFOBg8EweRhZPP5mgeoPwE7ofcNOcSWPYytsZ2Q8aMnv8B3PLiUmMZAAA=","debug_symbols":"3VfbjoIwEP2XPvPQmd79lc3GoKIhIWgQN9kQ/n1bQ7tYXHcjQlzfGHo4PdNpz5SGbLLVabfMy+3+SBZvDSn267TO96WNGkLPr46HtHTRsU6rmiwYYEKycuOeVJuQbV5kZCF1mwygGpTosBopBrCiV8CgtezAYCgLYOTte0JgVilGiCBF6b6UIZhL1WG56akWTjXOqRophQ5ssfx+1WxW1QDMqwZmorLzWaUg514KanZ7AYFpv4LAqYh0i3+qWz6vbsH8PgEh5P27W71+ivqJUwzMIMwIZzWvnyKMbr8IMuSIqp+jo4dp6XFCehusqrwo8t0yvrA0BK42DaDguyNQJm6XRVFfbwUY30TEtPRyPH2wEcXjhgrqAfS+hkoOrml6Wnoznl4bT29URI90WnoYTa8xnAke7xzEB9AHU7zsP46ejadXvrR6uDj8gfQmOlbt+QfiR2sA6j+0j/pvJwZ4cHmQv/RqTQX1iVN16fOtjT7SKk9XReY8zA2eyrW3NBvWnwc/4k3vUO3X2eZUZc7+es7n9i+qhOF3xudXImHUzmRn+wI=","file_map":{"24":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"68":{"source":"use dep::quantized::quantized::Quantized;\nuse std::cmp::Ordering;\n\n// addition, sub  17\n// mul 3229\n// div 3285\n// fn main(x: Quantized, y: Quantized) -> pub Quantized {\n//     // x + y\n//     // x - y\n//     // x * y\n//     x / y\n// }\n\n// ordering 2789\nfn main(x: Quantized, y: Quantized) -> pub Ordering {\n    x.cmp(y)\n}\n\n","path":"/home/hdvanegasm/Documents/hashcloak/aztec/grant/noir-fixed-point/benchmarks/project/src/main.nr"},"70":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Div, Mul, Sub};\n\n// IMPORTANT: This library is designed to work with a scale factor of 2^(8*factor).\n// See further explanation in the `Quantized` struct comments below.\nglobal factor: u32 = 2;\nglobal scale: Field = 65536; // 2^(8*2) = 2^16\n\n/////////// Other options:\n// global factor = 1\n// global scale = 256; // 2^(8*1) = 2^8\n\n// global factor = 3\n// global scale = 16777216; // 2^(8*3) = 2^24\n/////////// END Other options\n\n// A signed fixed-point number `x` is represented in a single Field element.\n//\n// Representation Overview:\n// A finite Field has 254 bits of \"space\". We represent positive fixed-point numbers\n// in the first half of these bits and negative fixed-point numbers in the second half.\n// Here's a visualization of the field element:\n// - Positive values have bits set in the lower part: |x,x,x,x,..,x, ... ,_,_,_,_|\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x,x,x,..,x|\n//\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\n// values around the field's modulus. For example, subtracting 5 from 3 in a field with\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\n// negative values to be correctly encoded in the field's upper range.\n//\n// Scaling:\n// Since fields do not inherently support decimal values, the fixed-point representation\n// uses scaling. For example, a scale of 2^-16 means that:\n// - `Quantized { x: 1 }` represents the value 1/2^16.\n// - To represent an original value, divide it by the scale, truncate, and store the result.\n// Example:\n// - Original value: 0.001\n// - Scaled value: 0.001 * 2^16 = 65.536\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\n//\n// Range and Precision:\n// A `Quantized` value can have a maximum of 60 bits, leaving room for additional operations\n// like multiplications and additions. This limits the stored value to the range:\n//   [-2^60 + 1, 2^60 - 1] (approximately -1.15e18 to 1.15e18).\n// The unscaled range is therefore:\n//   [-2^60/scale, 2^60/scale].\n//\n// Conversion Steps to `Quantized`:\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\n//    the field's prime modulus. Otherwise, proceed with `x`.\n// 2. Multiply the value by the scale factor (e.g., 2^16).\n// 3. Store the scaled value in a `Quantized` struct.\n//\n// Prime Modulus:\n// The field modulus `p` used in this implementation is:\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// This prime comes from the Barretenberg backend.\npub struct Quantized {\n    pub x: Field,\n}\n\npub unconstrained fn get_bytes(x: Field) -> [u8; 32] {\n    x.to_be_bytes()\n}\n\n// returns 1 for true, 0 for false (checking for this is cheaper than working with a bool)\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\n// Make sure that the value that the field contains has maximum ~127 bits\n// (otherwise a positive value will \"overflow\" into the higher bits, as well as a negative\n// value would overflow into lower bits)\nfn is_negative(x: Field) -> Field {\n    let (_, higher_bytes) = decompose(x);\n    if higher_bytes == 0 {\n        0\n    } else {\n        1\n    }\n}\n\nimpl Quantized {\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        Self { x: x }\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        // Perform multiplication of the underlying field elements\n        // This doubles the scale.\n        let mut temp: Field = self.x * other.x;\n\n        // Scaling down by converting to byte array and chopping off the needed amount of bytes\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\n        // temporarily, and flip it back at the end. Otherwise the chopping won't work.\n\n        let mut bytes: [u8; 32] = [0; 32];\n        // Check whether we're working with a negative value\n        let negative = is_negative(temp);\n\n        temp = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\n                    + 1\n                    - temp\n            )\n            + temp;\n\n        unsafe {\n            bytes = get_bytes(temp);\n        }\n\n        // Ensure the new bytes representation matches the field element\n        assert(Field::from_be_bytes::<32>(bytes) == temp);\n\n        // Truncate the bytes to scale down by 2^(8 * factor)\n        // This effectively \"chops off\" the least significant <factor> bytes\n        let mut truncated: [u8; 32] = [0; 32];\n        for i in 0..30 {\n            truncated[i + factor] = bytes[i];\n        }\n\n        // Reconstruct the field element from the truncated bytes\n        let mut new_x: Field = Field::from_be_bytes::<32>(truncated);\n\n        // If the result was originally negative, flip the sign back\n        new_x = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - new_x\n                    + 1\n                    - new_x\n            )\n            + new_x;\n\n        // Return the result as a new Quantized instance\n        Quantized { x: new_x }\n    }\n\n    fn div(self: Self, other: Self) -> Self {\n        // Ensure `other` is not zero\n        assert(other.x != 0, \"Division by zero is not allowed.\");\n\n        // Flip signs of numerator and denominator if negative, work with their absolute values\n        let mut numerator = self.x;\n        let mut denominator = other.x;\n\n        let mut numerator_is_negative = is_negative(numerator);\n        let mut denominator_is_negative = is_negative(denominator);\n\n        numerator = numerator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - numerator\n                    + 1\n                    - numerator\n            )\n            + numerator;\n\n        denominator = denominator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - denominator\n                    + 1\n                    - denominator\n            )\n            + denominator;\n\n        // Scale numerator before division\n        let scaled_numerator = numerator * scale;\n\n        // Cast to U128 for division\n        let scaled_numerator_u128 = U128::from_le_bytes(scaled_numerator.to_le_bytes());\n        let denominator_u128 = U128::from_le_bytes(denominator.to_le_bytes());\n\n        // Perform the division in U128\n        let result_u128 = scaled_numerator_u128 / denominator_u128;\n\n        // Cast back to Field\n        let mut result = Field::from_le_bytes(result_u128.to_le_bytes());\n\n        // Determine the sign of the result\n        let result_is_negative = numerator_is_negative + denominator_is_negative == 1;\n\n        // If result is negative, flip sign back\n        if result_is_negative {\n            result = 21888242871839275222246405745257275088548364400416034343698204186575808495616\n                - result\n                + 1;\n        }\n\n        Quantized { x: result }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Div for Quantized {\n    fn div(self, other: Self) -> Self {\n        self.div(other)\n    }\n}\n\nimpl Ord for Quantized {\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if self.x == other.x {\n            Ordering::equal()\n        }\n\n        let (_, sub_hi) = decompose(self.x - other.x);\n        if (sub_hi == 0) {\n            Ordering::greater()\n        } else {\n            Ordering::less()\n        }\n    }\n}\n\n#[test]\nfn test_order() {\n    // Test 1: comparison between positive and negative value.\n    // a = 0.2 and b = -0.2\n    let a: Field = 13107;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 2: comparison between two possitive numbers.\n    // a = 1 and b = 0.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 13107;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 3: comparison between two possitive numbers where the roles are\n    // inverted.\n    // a = 1 and b = 1.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 78643;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // Test 4: comparison between two negative numbers.\n    // a = -1 and b = -0.2.\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\n    // - 32768\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\n    // - 327680\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\n    assert(a > b);\n}\n\n#[test]\nfn test_is_negative() {\n    // Test 1: checking if it's negative for a positive value.\n    // a = 0.2   =>   0.2 * 2^16 = 13107\n    let a: Field = 13107;\n    assert(is_negative(a) == 0);\n\n    // Test 2: checking if it's negative for a negative value.\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    assert(is_negative(a) == 1);\n\n    // Test 3: checing if it's negative for a negative larger value.\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\n    assert(is_negative(a) == 1);\n}\n\n#[test]\nfn test_add() {\n    // Max value 2^60-1, positive and negative\n    let a = 1152921504606846975;\n    let b = -1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized + b_quantized;\n    assert(addition_quantized.x == 0);\n\n    // Test case 1: Max value 2^60 - 1, positive and zero\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized + b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    // Test case 2: Small positive values\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\n    let a3 = 50000;\n    let b3 = -30000;\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    let addition3_quantized = a3_quantized + b3_quantized;\n    assert(addition3_quantized.x == 20000);\n\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\n    let a4 = 30000;\n    let b4 = -50000;\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n    let addition4_quantized = a4_quantized + b4_quantized;\n    assert(addition4_quantized.x == -20000);\n\n    // Test case 5: Add two negative values resulting in a negative value\n    let a5 = -40000;\n    let b5 = -20000;\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    let addition5_quantized = a5_quantized + b5_quantized;\n    assert(addition5_quantized.x == -60000);\n}\n\n#[test]\nfn test_mul() {\n    // Test case 1: Small positive values\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\n    let mult1_quantized = a1_quantized * b1_quantized;\n    assert(mult1_quantized.x == 12788);\n\n    // Test case 2: Large positive values\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let mult2_quantized = a2_quantized * b2_quantized;\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\n    assert(mult2_quantized.x == 35184372088831);\n\n    // Test case 3: Large positive and small positive value\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\n    let mult3_quantized = a3_quantized * b3_quantized;\n    // mul * 2^16 = 17592186044415.9999847412109375\n    assert(mult3_quantized.x == 17592186044415);\n\n    // Test case 4: Positive and negative value\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\n    let b4 = -30000; // Original value -0.457763671875\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\n    let mult4_quantized = a4_quantized * b4_quantized;\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\n    assert(mult4_quantized.x == -18310);\n\n    // Test case 5: Both values negative\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\n    let b5 = -20000; // -0.30517578125\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\n    let mult5_quantized = a5_quantized * b5_quantized;\n    // Expected result: 12207.03125\n    assert(mult5_quantized.x == 12207);\n}\n\n#[test]\nfn test_sub() {\n    let a = 1152921504606846975;\n    let b = 1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized - b_quantized;\n    assert(addition_quantized.x == 0);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized - b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = b1_quantized - a1_quantized;\n    // The result should be -a1, which means it is p - a1 in the field because\n    // of the wrap around.\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\n    assert(addition1_quantized.x == result);\n\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n}\n\n#[test]\nfn test_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Division with small positive values\n    let a1 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b1 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result1 = a1 / b1; // 1.5 / 1.0 = 1.5\n    assert(result1.x == 98304); // Scaled result for 1.5\n\n    // Test case 2: Division resulting in a smaller value\n    let a2 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let b2 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let result2 = a2 / b2; // 1.0 / 1.5 = 0.666...\n    assert(result2.x == 43690); // Scaled result for ~0.6667\n\n    // Test case 3: Negative divided by positive\n    let a3 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b3 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result3 = a3 / b3; // -1.5 / 1.0 = -1.5\n    assert(result3.x == p - 98304); // Correctly negative\n\n    // Test case 4: Positive divided by negative\n    let a4 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b4 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result4 = a4 / b4; // 1.5 / -1.0 = -1.5\n    assert(result4.x == p - 98304); // Correctly negative\n\n    // Test case 5: Both negative values\n    let a5 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b5 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result5 = a5 / b5; // -1.5 / -1.0 = 1.5\n    assert(result5.x == 98304); // Scaled result for 1.5\n}\n\n#[test]\nfn test_large_values_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Large positive values\n    let a1 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b1 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result1 = a1 / b1; // 17592186044416.0 / 8796093022208.0 = 2.0\n    assert(result1.x == 131072); // Scaled result for 2.0\n\n    // Test case 2: Large positive divided by a larger positive\n    let a2 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let b2 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let result2 = a2 / b2; // 8796093022208.0 / 17592186044416.0 = 0.5\n    assert(result2.x == 32768); // Scaled result for 0.5\n\n    // Test case 3: Large negative divided by large positive\n    let a3 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b3 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result3 = a3 / b3; // -17592186044416.0 / 8796093022208.0 = -2.0\n    assert(result3.x == p - 131072); // Correctly negative\n\n    // Test case 4: Large positive divided by large negative\n    let a4 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b4 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result4 = a4 / b4; // 17592186044416.0 / -8796093022208.0 = -2.0\n    assert(result4.x == p - 131072); // Correctly negative\n\n    // Test case 5: Both large negative values\n    let a5 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b5 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result5 = a5 / b5; // -17592186044416.0 / -8796093022208.0 = 2.0\n    assert(result5.x == 131072); // Scaled result for 2.0\n}\n\n#[test(should_fail)]\nfn test_division_by_zero() -> Quantized {\n    Quantized { x: 65536 } / Quantized { x: 0 }\n}\n","path":"/home/hdvanegasm/Documents/hashcloak/aztec/grant/noir-fixed-point/lib/src/quantized.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","directive_invert"]}